#!/usr/bin/env python

# Script to retrieve statistics about bugs for source packages with various statuses
#

import datetime
import optparse
import socket
import simplejson as json
from optparse import OptionParser
from arsenal.arsenal_lib import *
from lpltk import LaunchpadService
from httplib import IncompleteRead
from httplib2 import ServerNotFoundError

usage = '''
%prog [OPTIONS] <source-package> [source-package ...]

At least one package must be specified either as an arg or via the -p flag.
'''
parser = optparse.OptionParser(usage=usage)
parser.add_option("-p", "--packages", help="Additional source packages - \
    srcpkg,srcpkg,...")
parser.add_option("-n", "--noexclude", help="Do not exclude tags (kubuntu, \
    xubuntu, ppc, omit) from search",
    action="store_false", dest="exclude")
parser.add_option("-t", "--team", help="Team name to write to json file")
parser.add_option("-q", "--query", action="store_true",
    help="Query Launchpad for team's subscribed packages")

parser.set_defaults(exclude=True)
(opt, args) = parser.parse_args()

source_pkgs  = []
if not opt.query:
    if opt.packages:
        for srcpkg in opt.packages.split(','):
            source_pkgs.append(srcpkg)
    elif len(args)>0:
        source_pkgs  = args
    if not source_pkgs:
        sys.stderr.write("Error: package names must be provided (or use --query)\n")
        parser.print_help()
        sys.exit(1)

if opt.exclude:
    tag_list = ['-kubuntu', '-xubuntu', '-ppc', '-omit']
elif not opt.exclude:
    tag_list = []

if not opt.team:
    team_name = 'ubuntu-x-swat'
else:
    team_name = opt.team

try:
    lp          = LaunchpadService(config={'read_only': False})
    d           = lp.distributions["ubuntu"]
except:
    sys.exit(7)
if not d:
    sys.stderr.write("Error:  Could not retrieve project from launchpad\n")
    sys.exit(1)

if opt.query:
    team = lp.launchpad.people[team_name]
    sub_pkgs = team.getBugSubscriberPackages()
    for sub_pkg in sub_pkgs:
        source_pkgs.append(sub_pkg.display_name.split(' ')[0])

devseries     = d.current_series.name
tag_sets      = [
    {"name":"all",         "tags":tag_list},
    {"name":devseries,     "tags":tag_list + devseries.split(' ')},
    ]

all_supported_series = d.supported_series
all_supported_series.append(d.current_series)
all_supported_series.append(d.stable_series)
for series in d.supported_series:
    name = series.name
    tag_sets.append({"name":name, "tags":tag_list + name.split(' ')})


useful_tags = ['apport-crash', 'apport-package', 'apport-bug',
               'regression-release', 'regression-proposed',
               'regression-updates', 'bugpattern-needed']

for tag in useful_tags:
    tag_sets.append({"name":tag, "tags": tag_list + [tag]})

records = { 'timestamp-start': str(datetime.datetime.now()),
            'team': team_name,
            'dev-series': devseries,
            'data': [],
            }

try:
    for source_pkg in source_pkgs:
        # Reset launchpad, to avoid time outs (HTTP Error 401: Unauthorized)
        lp = LaunchpadService(config={'read_only': False})
        d = lp.launchpad.distributions["ubuntu"]

        s = d.getSourcePackage(name = source_pkg)
        bug_tracker_url = None
        up = s.upstream_product
        if (up is not None and up.bug_tracker is not None):
            try:
                bug_tracker_url = up.bug_tracker.base_url
            except json.decoder.JSONDecodeError as e:
                sys.stderr.write("\n\n%s\n\n" %(e.doc))
                raise
            except:
                sys.stderr.write("Error trying to determine bug tracker url for %s\n" %(source_pkg))
                raise
        statistics = {}

        for tag_set in tag_sets:
            n = tag_set['name']
            tags = tag_set['tags']

            tasks = s.searchTasks(tags = tags, tags_combinator = "All")
            if len(list(tasks)) == 0:
                # If there are no open bug_tasks, don't bother recording them
                continue
            statistics[n+'-total'] = len(list(tasks))

            tasks = s.searchTasks(status='New', tags=tags, tags_combinator="All")
            statistics[n+'-new'] = len(list(tasks))

            tasks = s.searchTasks(status = 'Incomplete (without response)', tags=tags, tags_combinator="All")
            statistics[n+'-incomplete'] = len(list(tasks))

            tasks = s.searchTasks(status = 'Incomplete (with response)', tags=tags, tags_combinator="All")
            statistics[n+'-responded'] = len(list(tasks))

            tasks = s.searchTasks(status = 'Confirmed', status_upstream=None, tags=tags, tags_combinator="All")
            statistics[n+'-confirmed'] = len(list(tasks))

            tasks = s.searchTasks(status = 'Triaged', status_upstream=None, tags=tags, tags_combinator="All")
            statistics[n+'-triaged'] = len(list(tasks))

            tasks = s.searchTasks(has_patch = True, tags=tags, tags_combinator="All")
            statistics[n+'-has-patch'] = len(list(tasks))

            tasks = s.searchTasks(status_upstream = 'resolved_upstream', tags=tags, tags_combinator="All")
            statistics[n+'-resolved-upstream'] = len(list(tasks))

            tasks = s.searchTasks(status_upstream = 'open_upstream', tags=tags, tags_combinator="All")
            statistics[n+'-open-upstream'] = len(list(tasks))

            # Count of bugs with open tasks against the official bug tracker for the package
            tot = 0
            for task in tasks:
                tid = task.bug.id
                try:
                    for sibling_task in task.related_tasks:
                        if sibling_task.bug_watch is None:
                            continue
                        bt = sibling_task.bug_watch.bug_tracker
                        if bt is None:
                            continue
                        if bt.base_url == bug_tracker_url:
                            tot += 1
                            break
                except:
                    # Bugs 781391, 541471, 605979, 529934 trip this up
                    #sys.stderr.write("Failure reading sibling tasks of %d %s\n" %(tid, source_pkg))
                    #raise
                    continue
            statistics[n+'-upstreamed'] = tot

        if len(statistics)>0:
            records['data'].append({source_pkg: statistics})

except HTTPError, e:
    if is_launchpad_down(e):
        # TODO: Verify script has run successfully once in past day or so
        sys.exit(7)
    else:
        sys.stderr.write("HTTPError Exception processing %s: %s\n" %(source_pkg, e))
        raise
except IncompleteRead as e:
    # Launchpad got interrupted before it could give all the data (I guess)
    # The following error message can be removed once it's verified to work
    sys.stderr.write("IncompleteRead exception: %s" %(e))
    sys.exit(7)
except socket.error as e:
    # Network is down.  Skip for now
    sys.exit(7)
except:
    sys.stderr.write("Unknown exception encountered in collect-team-bugtotals\n")
    raise

records['timestamp-stop'] = str(datetime.datetime.now())

print json.dumps(records, indent=4)
