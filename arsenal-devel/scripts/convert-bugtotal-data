#!/usr/bin/env python

import os
import sys
import re
import string
import datetime
import simplejson as json
from optparse import OptionParser

def loadfile(filename):
    in_file = open(filename, "r")
    text = in_file.read()
    in_file.close()
    return text

def date_from_json_filename(name):
    regex_date = re.compile(".*-(\d+)\.json")
    m = regex_date.search(name)
    if not m:
        return None
    return m.group(1)

def main():
    parser = OptionParser()
    parser.add_option( "--workqueue", action="store_true", dest="workqueue",
                       help="Only include counts of bugs needing maintainer attention")
    parser.add_option( "--series", action="store", dest="series",
                       help="Only include counts of bugs needing maintainer attention")
    parser.add_option( "--type=s", action="store", dest="type",
                       help="Type of data items ('tags', 'importance', etc. to include)")
    parser.add_option( "--add-days=d", action="store", dest="add_days",
                       help="Display a date advanced by this number of days")
    parser.add_option( "--omit-header=d", action="store", dest="omit_header",
                       help="Suppress display of the header line")
    parser.add_option( "--columns=s", action="store", dest="column_order",
                       help="Ordered list of columns to display first")
    (options, args) = parser.parse_args()

    # TODO: Option to sort columns by # bugs at start or end

    if options.series is not None:
        field = "%s-total" %(options.series)
        series = options.series
    else:
        field = 'all-total'
        series = None

    if len(args) < 1:
        sys.stderr.write("Usage:  convert-bugtotal-data <json-file>\n")
        sys.exit(1)

    columns = []
    dates = []
    results = {}
    for f in args[0:]:
        try:
            text = loadfile(f)
        except:
            sys.stderr.write("Error:  File %s could not be loaded\n" %(f))
            sys.exit(1)
        if not text:
            sys.stderr.write("Error:  Content from %s could not be loaded\n" %(f))
            sys.exit(1)
        try:
            js = json.loads(text)
        except:
            sys.stderr.write("Error:  Invalid json text for file %s\n" %(f))
            raise

        date = date_from_json_filename(f)
        if series and 'dev-series' in js and js['dev-series'] != series:
            # This is not the development series we're looking for
            continue
        if options.add_days:
            date_obj = datetime.datetime.strptime(date, "%Y%m%d").date()
            new_date = date_obj + datetime.timedelta(days=int(options.add_days))
            date = new_date.strftime("%Y%m%d")
        dates.append(date)
        results[date] = js

        if options.type:
            first_project = js['data'][0]
            first_project_name = first_project.keys()[0]
            project_data = first_project[first_project_name]
            if options.type not in project_data.keys():
                sys.stderr.write("Error: No data group for type '%s' in project %s\n"
                                 %(options.type, first_project))
                print project_data
                sys.exit(1)
            columns = project_data[options.type].keys()
        else:
            for pkg_data in js['data']:
                col = pkg_data.keys()[0]
                if col not in columns and field in pkg_data[col] and pkg_data[col][field] > 0:
                    columns.append(col)
        # TODO: Skip unless data['dev-series'] == series

    if len(dates)<1:
        # No data for this case, can just ignore
        #sys.stderr.write("Error: Could not determine date from filename(s)\n")
        #sys.stderr.write(' '.join(args))
        sys.exit(1)

    if options.column_order:
        ordered_columns = options.column_order.split(',')
        for col in columns:
            if col not in ordered_columns:
                ordered_columns.append(col)
        columns = ordered_columns
    else:
        columns.sort()
    nickname_columns = []
    for col in columns:
        x = col
        x = x.replace(" ", "_")
        nickname_columns.append(x)

    if not options.omit_header:
        print "Date " + string.join(nickname_columns, " ")
    print dates[0] + "   0" * len(columns)

    columns.reverse()
    for date in dates:
        line = ""
        tot = 0

        for col in columns:
            if options.type:
                for dataset in results[date]['data']:
                    for project_name, project in dataset.iteritems():
                        stats = project[options.type]
                        if col in stats:
                            tot += stats[col]

            else:
                for pkg_data in results[date]['data']:
                    pkg = pkg_data.keys()[0]
                    if pkg == col:
                        if options.workqueue:
                            for field_part in ['-new', '-responded', '-confirmed', '-triaged']:
                                field = series+field_part
                                if field in pkg_data[pkg]:
                                    tot += pkg_data[pkg][field]

                            ## Exclude bugs that are open upstream
                            for field_part in ['-upstreamed']:
                                field = series+field_part
                                if field in pkg_data[pkg]:
                                    tot -= pkg_data[pkg][field]
                        else:
                            if field in pkg_data[pkg]:
                                tot += pkg_data[pkg][field]
                        exit

            line = "%3d %s" %(tot, line)

        print "%s %s" %(date, line)

    print dates[len(dates)-1] + "   0" * len(columns)

main()
