#!/usr/bin/env python

import sys, os.path
sys.path.insert(0, os.path.realpath(
        os.path.join(os.path.dirname(__file__), "..")))

from sys                                import argv, stdout, exit
from getopt                             import getopt, GetoptError
from datetime                           import datetime
import json
import re

from arsenal.dbg                        import Dbg
from arsenal.utils                      import stdo, error, json_load, file_load, FileDoesntExist, dump, date_to_string
from arsenal.cfg                        import Cfg, CfgError
from arsenal.bugs                       import DeltaTime
from arsenal.kernel_bug                 import KernelBug

from lpltk.LaunchpadService             import LaunchpadService

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
class Cmdline:
    """
    Handle all the command line processing for the application.
    """
    # error
    #
    def error(self, e, defaults):
        """
        Simple helper which prints out an error message and then prints out the usage.
        """
        if e != '': error("%s\n" % e)
        self.usage(defaults)

    # usage
    #
    def usage(self, defaults):
        """
        Prints out the help text which explains the command line options.
        """
        stdo('    Usage:                                                                                   \n')
        stdo('        %s [Options] <json-db-file>                                                          \n' % defaults['app_name'])
        stdo('                                                                                             \n')
        stdo('    Options:                                                                                 \n')
        stdo('        --help           Prints this text.                                                   \n')
        stdo('                                                                                             \n')
        stdo('        --debug=<debug options>                                                              \n')
        stdo('                         Performs additional output related to the option enabled and        \n')
        stdo('                         the application defined support for the option.                     \n')
        stdo('                                                                                             \n')
        stdo('                         Recognized debug options:                                           \n')
        stdo('                             enter                                                           \n')
        stdo('                             leave                                                           \n')
        stdo('                             verbose                                                         \n')
        stdo('                             cfg                                                             \n')
        stdo('                                                                                             \n')
        stdo('        --privates      Include private bugs in the results.                                 \n')
        stdo('                                                                                             \n')
        stdo('    Examples:                                                                                \n')
        stdo('        %s iso-testing-bugs.json                                                             \n' % defaults['app_name'])
        stdo('        %s --debug="enter,leave,verbose"                                                     \n' % defaults['app_name'])

    # process
    #
    def process(self, argv, defaults):
        """
        This method is responsible for calling the getopt function to process the command
        line. All parameters are processed into class variables for use by other methods.
        """
        result = True
        try:
            cfg = defaults
            optsShort = ''
            optsLong  = ['help', 'debug=', 'privates']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif opt in ('--debug'):
                    cfg['debug'] = val.split(',')
                    for level in cfg['debug']:
                        if level not in Dbg.levels:
                            Dbg.levels.append(level)

                elif opt in ('--privates'):
                    cfg['show_private_bugs'] = True

            if result: # No errors yet
                # There might be some bugs listed on the command line.
                #
                if len(args) > 0:
                    cfg['json_file'] = args

        except GetoptError, error:
            raise CmdlineError(error)

        # Verify we have all the command line options that are required.
        #
        if 'json_file' not in cfg:
            raise CmdlineError("A single json data file must be specified.\n")

        if len(cfg['json_file']) > 1:
            raise CmdlineError("A single json data file must be specified.\n")

        cfg['json_file'] = cfg['json_file'][0]

        return cfg


# Exit
#
class Exit():
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass

# CollectBugData
#
class CollectBugData():
    """
    Load a json file and a mako html template file, pass the resulting python object to
    the mako template renderer. This is a general class that can take any json file and
    any mako template file and produce an html file. The template file is, of course,
    specific to the json data.
    """

    # __init__
    #
    def __init__(self, cfg):
        Dbg.enter("CollectBugData.__init__")

        self.cfg    = cfg

        Dbg.leave("CollectBugData.__init__")

    # initialize
    #
    def initialize(self):
        """
        A separate initialize that we can control when it gets called (not
        when the object is instantiated).
        """
        Dbg.enter("CollectBugData.initialize")

        try:
            # Process the command line arguments, and any configuration file options. Make sure
            # that any required parameters have been provided.
            #
            self.cfg = Cfg.merge_options(defaults, self.cfg)

            self.iso_config = json_load(self.cfg['json_file'])

            Dbg.verbose(' . Connecting to Launchpad\n')
            self.lp = LaunchpadService(self.iso_config['launchpad_config'])

            self.initialize_team_package_crossreference()
            self.initialize_milestone_date_crossreference('oneiric')

        except KeyboardInterrupt:
            Dbg.leave("CollectBugData.initialize")
            raise Exit()

        except CfgError as e:
            error(e)
            Dbg.leave("CollectBugData.initialize")
            raise Exit()

        except FileDoesntExist as e:
            e.print_std_error()
            Dbg.leave("CollectBugData.initialize")
            raise Exit()

        Dbg.leave("CollectBugData.initialize")
        return

    # initialize_team_package_crossreference
    #
    def initialize_team_package_crossreference(self):
        Dbg.enter("CollectBugData.initialize_team_package_crossreference")
        self.team_xref = {
            'linux'           : 'Kernel Team',
            'linux-ti-omap4'  : 'Kernel Team',
            'indicator-sound' : 'DX Team',
        }

        team_name_xref = {
            'foundations-bugs'            : 'Foundations Team',
            'ubuntu-server'               : 'Server Team',
            'desktop-packages'            : 'Desktop Team',
            'unity-bugs'                  : 'DX Team',
            'unity-2d-team'               : 'DX Team',
            'indicator-applet-developers' : 'DX Team',
            'ubuntuone-hackers'           : 'Ubuntu One Team'
        }

        for a_team in team_name_xref:
            Dbg.verbose("%s\n" % a_team)
            team = self.lp.launchpad.people[a_team]
            for p in team.getBugSubscriberPackages():
                self.team_xref[p.name] = team_name_xref[a_team]

        Dbg.leave("CollectBugData.initialize_team_package_crossreference")

    # initial_milestone_date_crossreference
    #
    def initialize_milestone_date_crossreference(self, series):
        Dbg.enter("CollectBugData.initialize_milestone_date_crossreference")

        self.milestone_date_xref = {}
        lp_distro = self.lp.distributions['ubuntu/%s' % series]
        lp_active = lp_distro.all_milestones
        for lp_milestone in lp_active:
            if lp_milestone.date_targeted is None: continue
            milestone = self.decode_milestone(lp_milestone.name)
            self.milestone_date_xref[milestone] = lp_milestone.date_targeted

        Dbg.enter("CollectBugData.initialize_milestone_date_crossreference")

    def decode_milestone(self, milestone_name):
        Dbg.enter("CollectBugData.decode_milestone")

        retval = ''
        if 'alpha' in milestone_name or 'beta' in milestone_name:
            fields = milestone_name.split('-')
            which = fields[len(fields)-1]
            if which.isdigit():
                retval = '%s-%s' % (fields[len(fields)-2], which)
            else:
                retval = '%s-1' % (which)
        else:
            retval = 'release'

        Dbg.leave("CollectBugData.decode_milestone")
        return retval

    # determine_milestone_found
    #
    def determine_milestone_found(self, date):
        Dbg.enter("CollectBugData.determine_milestone_found")

        retval = ''

        comp = date.replace(tzinfo=None)
        prev_milestone = ''
        for m in sorted(self.milestone_date_xref):
            if comp < self.milestone_date_xref[m]:
                retval = prev_milestone
                break
            prev_milestone = m

        Dbg.leave("CollectBugData.determine_milestone_found")
        return retval

    # project_tasks_search
    #
    def project_tasks_search(self, search_criteria, series, project):
        Dbg.enter("CollectBugData.project_tasks_search")

        lp_project = self.lp.projects[project]

        try:
            search_tags = search_criteria['tags']
        except KeyError:
            search_tags = []
        Dbg.verbose('search: tags: \'%s\'\n' % ','.join(search_tags))

        try:
            search_tags_combinator = search_criteria['tags_combinator']
        except KeyError:
            search_tags_combinator = 'Any'
        Dbg.verbose('search: tags_combinator: \'%s\'\n' % search_tags_combinator)

        try:
            search_status = search_criteria['status']
        except KeyError:
            search_status = []
        Dbg.verbose('search: status: \'%s\'\n' % ','.join(search_status))

        Dbg.leave("CollectBugData.project_tasks_search")
        return lp_project.search_tasks(tags=search_tags, tags_combinator=search_tags_combinator, status=search_status)

    # main
    #
    def main(self):
        Dbg.enter("CollectBugData.main")
        retval = -1

        try:
            self.initialize()

            search_start = datetime.utcnow()
            iso_tasks = {}

            # For each 'search_criteria' section of the config file:
            #
            for sc in self.iso_config['search_criteria']:
                try:
                    series = sc['series']
                except KeyError:
                    series = ["NONE"]

                try:
                    projects = sc['projects']
                except KeyError:
                    error("Use the other cbd script if you don't have any projects.")
                    raise Exit()

                # For each 'series' within the 'search_criteria' section of the
                # config file:
                #
                for s in series:

                    # For each 'project' within the 'search_criteria' section of the
                    # config file:
                    #
                    for p in projects:
                        # Perform the search and loop over the search results.
                        #
                        for task in self.project_tasks_search(sc, s, p):
                            stdo("%s\r" % task.bug.id)

                            if task.bug.id not in iso_tasks:
                                iso_tasks[task.bug.id] = []

                            try:
                                if not task.bug.private or self.cfg['show_private_bugs']:
                                    t = self.get_task_info(task, p)
                                    t_name = t['bug_target_name']
                                    matched = False
                                    for tt in iso_tasks[task.bug.id]:
                                        if t_name == tt['bug_target_name']:
                                            matched = True

                                    if not matched:
                                        iso_tasks[task.bug.id].append(t)

                                else:
                                    print("it's private")
                            except:
                                print('Exception caught processing bug: %s' % task.bug.id)
                                raise

            # Update the configuration file with the LP data and the timestamp
            #
            self.iso_config['tasks'] = iso_tasks
            self.iso_config['update_timestamp'] = date_to_string(search_start)
            with open(self.cfg['json_file'], 'w') as f:
                Dbg.verbose("Updating the database file.\n")
                f.write(json.dumps(self.iso_config, sort_keys=True, indent=4))

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        except Exit:
            pass

        Dbg.leave("CollectBugData.main")
        return retval

    # get_task_info
    #
    def get_task_info(self, task, project):
        Dbg.enter("CollectBugData.get_task_info")

        t = {}

        m = re.search('(\S+)\s\(.*\)', task.bug_target_name)
        if m is not None:
            name = m.group(1)
        else:
            name = task.bug_target_name

        t['bug_target_name'] = name
        if t['bug_target_name'] in self.team_xref:
            t['team'] = self.team_xref[t['bug_target_name']]
        else:
            t['team'] = ''
        t['status'] = task.status
        t['importance'] = task.importance

        try:
            t['assignee'] = task.assignee.display_name
        except:
            t['assignee'] = 'Unassigned'

        t['project'] = project
        t['date_created'] = date_to_string(task.date_created)
        t['date_confirmed'] = date_to_string(task.date_confirmed)
        t['date_assigned'] = date_to_string(task.date_assigned)
        t['date_closed'] = date_to_string(task.date_closed)
        t['date_fix_committed'] = date_to_string(task.date_fix_committed)
        t['date_fix_released'] = date_to_string(task.date_fix_released)
        t['date_in_progress'] = date_to_string(task.date_in_progress)
        t['date_incomplete'] = date_to_string(task.date_incomplete)
        t['date_left_closed'] = date_to_string(task.date_left_closed)
        t['date_left_new'] = date_to_string(task.date_left_new)
        t['date_triaged'] = date_to_string(task.date_triaged)
        t['is_complete'] = task.is_complete
        t['owner'] = task.owner.display_name
        t['title'] = task.title
        t['web_link'] = task.web_link

        try:
            t['milestone_target'] = self.decode_milestone(task.milestone.name)
        except:
            t['milestone_target'] = ''

        t['milestone_found'] = self.determine_milestone_found(task.date_created)

        b = {}
        bug = KernelBug(task.bug)
        b['id'] = bug.id

        b['tags'] = []
        for tag in bug.tags:
            b['tags'].append(tag)

        b['title'] = bug.title

        created = bug.date_created
        b['date_created']      = date_to_string(created)
        b['date_last_message'] = date_to_string(bug.date_last_message)
        b['date_last_updated'] = date_to_string(bug.date_last_updated)
        b['heat']              = bug.heat
        b['number_of_duplicates'] = bug.lpbug.number_of_duplicates
        b['number_of_messages'] = len(bug.messages)
        b['number_affected']    = bug.lpbug.users_affected_count
        subs_num = 0
        for sub in bug.lpbug.subscriptions:
            subs_num += 1
        b['number_subscribed']  = subs_num

        b['nominations'] = []
        for nom in bug.nominations:
            if nom.status == 'Approved':
                b['nominations'].append(nom.target.name)

        (b['age_days'], b['age_hours'], b['age_minutes']) = self.how_long_ago(bug.date_created)
        b['iso_date_created']  = '%s (%d)' % (created.strftime("%Y/%m/%d"), b['age_days'])

        (b['series_name'], b['series_version']) = bug.series

        # LiveMediaBuild property
        #
        try:
            lmb = bug.properties['LiveMediaBuild']
            m = re.search('(\S+) (\d+.\d+[.\d+]).*"(\S+ \S+)" - (\S+) (\S+) \((\d+)\)', lmb)
            if m is not None:
                lmb = {}
                lmb['distro'] = m.group(1)
                lmb['version'] = m.group(2)
                lmb['name'] = m.group(3)
                lmb['milestone'] = m.group(4)
                lmb['arch'] = m.group(5)
                lmb['date'] = m.group(6)
                b['LiveMediaBuild'] = lmb

        except:
            pass

        t['bug'] = b

        Dbg.leave("CollectBugData.get_task_info")
        return t

    def how_long_ago(self, date):
        now = datetime.utcnow()
        now.replace(tzinfo=None)
        ago = DeltaTime(date, now)
        when = '%d.%d.%d' % (ago.days, ago.hours, ago.minutes)

        return (ago.days, ago.hours, ago.minutes)

if __name__ == '__main__':
    defaults = {}
    defaults['app_name'] = argv[0]
    defaults['show_private_bugs'] = False

    # The cmdline processing is done here partially so the debug options
    # can be processed right away.
    #
    cmdline = Cmdline()
    try:
        app = CollectBugData(cmdline.process(argv, defaults))
        exit(app.main())
    except CmdlineError as e:
        cmdline.error(e.msg, defaults)

# vi:set ts=4 sw=4 expandtab:

