#!/usr/bin/env python

import sys,os.path
sys.path.insert(0, os.path.realpath(
        os.path.join(os.path.dirname(__file__), "..")))

from sys                                import argv, exit
from getopt                             import getopt, GetoptError
from datetime                           import datetime
import json
import re

from lazr.restfulclient.errors          import HTTPError


from arsenal.dbg                        import Dbg
from arsenal.utils                      import stdo, error, json_load, FileDoesntExist, date_to_string, o2ascii, string_to_date
from arsenal.cfg                        import Cfg, CfgError
from arsenal.bugs                       import DeltaTime
from arsenal.kernel_bug                 import KernelBug
from arsenal.ubuntu                     import Ubuntu

from lpltk.LaunchpadService             import LaunchpadService

search_assignee_names = []
# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
class Cmdline:
    """
    Handle all the command line processing for the application.
    """
    # error
    #
    def error(self, e, defaults):
        """
        Simple helper which prints out an error message and then prints out the usage.
        """
        if e != '': error("%s\n" % e)
        self.usage(defaults)

    # usage
    #
    def usage(self, defaults):
        """
        Prints out the help text which explains the command line options.
        """
        stdo('    Usage:                                                                                   \n')
        stdo('        %s [Options] <json-db-file>                                                          \n' % defaults['app_name'])
        stdo('                                                                                             \n')
        stdo('    Options:                                                                                 \n')
        stdo('        --help           Prints this text.                                                   \n')
        stdo('                                                                                             \n')
        stdo('        --debug=<debug options>                                                              \n')
        stdo('                         Performs additional output related to the option enabled and        \n')
        stdo('                         the application defined support for the option.                     \n')
        stdo('                                                                                             \n')
        stdo('                         Recognized debug options:                                           \n')
        stdo('                             enter                                                           \n')
        stdo('                             leave                                                           \n')
        stdo('                             verbose                                                         \n')
        stdo('                             cfg                                                             \n')
        stdo('                                                                                             \n')
        stdo('        --cached-lp-resources=<resource-file>                                                \n')
        stdo('                         Points to the resource file to be used. The resource file           \n')
        stdo('                         contains the mappings from packages to teams and from               \n')
        stdo('                         milestone to milestone-date.                                        \n')
        stdo('                                                                                             \n')
        stdo('        --privates      Include private bugs in the results.                                 \n')
        stdo('                                                                                             \n')
        stdo('        --reload-bugs   Instead of only getting data about updated bugs - get all bug data   \n')
        stdo('                                                                                             \n')
        stdo('    Examples:                                                                                \n')
        stdo('        %s iso-testing-bugs.json                                                             \n' % defaults['app_name'])
        stdo('        %s --debug="enter,leave,verbose"                                                     \n' % defaults['app_name'])

    # process
    #
    def process(self, argv, defaults):
        """
        This method is responsible for calling the getopt function to process the command
        line. All parameters are processed into class variables for use by other methods.
        """
        result = True
        try:
            cfg = defaults
            optsShort = ''
            optsLong  = ['help', 'debug=', 'cached-lp-resources=', 'quiet', 'privates', 'reload-bugs']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif opt in ('--quiet'):
                    cfg['run_quietly'] = True

                elif opt in ('--debug'):
                    cfg['debug'] = val.split(',')
                    for level in cfg['debug']:
                        if level not in Dbg.levels:
                            Dbg.levels.append(level)

                elif opt in ('--privates'):
                    cfg['show_private_bugs'] = True

                elif opt in ('--reload-bugs'):
                    cfg['updated_only'] = False

                elif opt in ('--cached-lp-resources'):
                    cfg['cached_resources'] = val

            if result: # No errors yet
                # There might be some bugs listed on the command line.
                #
                if len(args) > 0:
                    cfg['json_file'] = args

        except GetoptError, error:
            raise CmdlineError(error)

        # Verify we have all the command line options that are required.
        #
        if 'json_file' not in cfg:
            raise CmdlineError("A single json data file must be specified.\n")

        if len(cfg['json_file']) > 1:
            raise CmdlineError("A single json data file must be specified.\n")

        cfg['json_file'] = cfg['json_file'][0]

        return cfg


# Exit
#
class Exit():
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass

# CollectBugData
#
class CollectBugData():
    """
    Load a json file and a mako html template file, pass the resulting python object to
    the mako template renderer. This is a general class that can take any json file and
    any mako template file and produce an html file. The template file is, of course,
    specific to the json data.
    """

    # __init__
    #
    def __init__(self, cfg):
        Dbg.enter("CollectBugData.__init__")

        self.cfg    = cfg
        self.ubuntu = Ubuntu()

        Dbg.leave("CollectBugData.__init__")

    # initialize
    #
    def initialize(self):
        """
        A separate initialize that we can control when it gets called (not
        when the object is instantiated).
        """
        Dbg.enter("CollectBugData.initialize")

        try:
            # Process the command line arguments, and any configuration file options. Make sure
            # that any required parameters have been provided.
            #
            # config options should be a combination of command line and the
            # json file with command line options taking precedence
            config_options = self.cfg
            self.cfg = Cfg.merge_options(defaults,
                json_load(config_options['json_file'])['launchpad_config'])
            Dbg.verbose('Config options after json parsing:\n  %s' % self.cfg)
            self.cfg = Cfg.merge_options(self.cfg, config_options)
            Dbg.verbose('Config options after cli parsing:\n  %s' % self.cfg)

            self.iso_config = json_load(self.cfg['json_file'])

            Dbg.verbose(' . Connecting to Launchpad\n')
            defs = {}
            for k in self.iso_config.keys():
                defs[o2ascii(k)] = self.iso_config[k]  # defs[o2ascii(k)] = o2ascii(self.iso_config[k])
            self.lp = LaunchpadService(defs)

            if 'cached_resources' in self.cfg:
                self.cached_lp_resources = json_load(self.cfg['cached_resources'])

                # We want the dates in the milestone map be a datetime object
                # and not a string.
                #
                if 'milestone_date_xref' in self.cached_lp_resources:
                    for k in self.cached_lp_resources['milestone_date_xref']:
                        self.cached_lp_resources['milestone_date_xref'][k] = string_to_date(self.cached_lp_resources['milestone_date_xref'][k])
                else:
                    self.cached_lp_resources['milestone_date_xref'] = {}
            else:
                self.cached_lp_resources = {}
                self.cached_lp_resources['milestone_date_xref'] = {}
                self.cached_lp_resources['team_xref'] = {}

            self.team_xref = self.cached_lp_resources['team_xref']

        except KeyboardInterrupt:
            Dbg.leave("CollectBugData.initialize")
            raise Exit()

        except CfgError as e:
            error(e)
            Dbg.leave("CollectBugData.initialize")
            raise Exit()

        except FileDoesntExist as e:
            e.print_std_error()
            Dbg.leave("CollectBugData.initialize")
            raise Exit()

        Dbg.leave("CollectBugData.initialize")
        return

    def decode_milestone(self, milestone_name):
        Dbg.enter("CollectBugData.decode_milestone")

        retval = ''
        fields = milestone_name.split('-')
        if 'ubuntu' in fields[0]:
            s = self.ubuntu.lookup(fields[1])
            retval = s['name'][0].title()
        else:
            retval = fields[0][0].title()

        if 'alpha' in milestone_name or 'beta' in milestone_name:
            fields = milestone_name.split('-')
            which = fields[len(fields)-1]
            if which.isdigit():
                retval += ' %s-%s' % (fields[len(fields)-2], which)
            else:
                retval += ' %s-1' % (which)
        elif 'updates' in milestone_name:
            retval += ' updates'
        else:
            retval += ' release'

        Dbg.leave("CollectBugData.decode_milestone")
        return retval

    # determine_milestone_found
    #
    def determine_milestone_found(self, date):
        Dbg.enter("CollectBugData.determine_milestone_found")

        retval = ''

        comp = date.replace(tzinfo=None)
        prev_milestone = ''
        for m in sorted(self.cached_lp_resources['milestone_date_xref']):
            if comp < self.cached_lp_resources['milestone_date_xref'][m]:
                retval = prev_milestone
                break
            prev_milestone = m

        Dbg.leave("CollectBugData.determine_milestone_found")
        return retval

    # distro_tasks_search
    #
    def distro_tasks_search(self, search_criteria, series, last_run_time):
        Dbg.enter("CollectBugData.distro_tasks_search")

        # Pull all the search parameters from the configuration dictionary
        #
        if 'distribution' in search_criteria:
            distro_name = search_criteria['distribution']
            if series != 'NONE':
                distro_name = "%s/%s" % (distro_name, series)
                Dbg.verbose('search: distro_name: \'%s\'\n' % distro_name)
                distro = self.lp.distributions[distro_name]
                lp_project = None
        else:
            project_name = search_criteria['project']
            Dbg.verbose('search: project_name: \'%s\'\n' % project_name)
            distro = self.lp.projects[project_name]
            lp_project = distro

        try:
            search_tags = search_criteria['tags']
        except KeyError:
            search_tags = []
        Dbg.verbose('search: tags: \'%s\'\n' % ','.join(search_tags))

        try:
            search_tags_combinator = search_criteria['tags_combinator']
        except KeyError:
            search_tags_combinator = 'Any'
        Dbg.verbose('search: tags_combinator: \'%s\'\n' % search_tags_combinator)

        try:
            search_status = search_criteria['status']
        except KeyError:
            search_status = []
        Dbg.verbose('search: status: \'%s\'\n' % ','.join(search_status))

        try:
            search_importance = search_criteria['importance']
        except KeyError:
            search_importance = []
        Dbg.verbose('search: importance: \'%s\'\n' % ','.join(search_importance))

        try:
            search_order = search_criteria['order_by']
        except KeyError:
            search_order = '-datecreated'

        try:
            sc_milestone = search_criteria['milestone']
            search_milestones = [m for m in distro.all_milestones
                if m.name in sc_milestone]
            if len(search_milestones) >= 2:
                print('You may only have one milestone.')
                exit(1)
            else:
                search_milestone = search_milestones[0].raw
        except KeyError:
            search_milestone = None

        try:
            search_limit = int(search_criteria['limit'])
        except KeyError:
            search_limit = ''

        try:
            search_reporters = search_criteria['reporters'].split(',')
        except KeyError:
            search_reporters = ''
        Dbg.verbose('search: reporters: \'%s\'\n' % ','.join(search_reporters))

        try:
            search_assignees = search_criteria['assignees'].split(',')
        except KeyError:
            search_assignees = ''
        Dbg.verbose('search: assignees: \'%s\'\n' % ','.join(search_assignees))

        try:
            search_subscribers = search_criteria['subscribers'].split(',')
        except KeyError:
            search_subscribers = ''
        Dbg.verbose('search: subscribers: \'%s\'\n' % ','.join(search_subscribers))

        try:
            reopened = search_criteria['reopened']
        except KeyError:
            reopened = False

        try:
            statuslength = search_criteria['days-in-state']
        except KeyError:
            statuslength = False

        try:
            implength = search_criteria['days-with-importance']
        except KeyError:
            implength = False

        # ensure that only one of these are selected
        count = 0
        if search_assignees != '':
            count += 1
        if search_reporters != '':
            count += 1
        if search_subscribers != '':
            count += 1

        if count > 1:
            print('You must choose either assignees, reporters or subscribers')
            exit(1)

        Dbg.leave("CollectBugData.distro_tasks_search")

        search_args = {'tags': search_tags,
                'tags_combinator': search_tags_combinator,
                'status': search_status,
                'importance': search_importance,
                'modified_since': last_run_time,
                'order_by': search_order}

        if search_milestone:
            search_args['milestone'] = search_milestone

        if search_reporters != '':
            reported_tasks = []
            for reporter in search_reporters:
                search_reporter = self.lp.launchpad.people[reporter]
                if search_reporter.is_team is False:
                    search_args['bug_reporter'] = search_reporter
                    tasks = distro.search_tasks(**search_args)
                    if reopened:
                        tasks.set_filter_reopened()
                    if statuslength:
                        tasks.set_filter_status_length(statuslength)
                    if implength:
                        tasks.set_filter_status_length(implength)
                    reported_tasks.append(tasks)
                else:
                    for participant in search_reporter.participants:
                        if participant.is_team:
                            continue
                        if not participant.is_valid:
                            continue
                        search_args['bug_reporter'] = participant
                        Dbg.verbose("search: reporter: %s\n" % participant.name)
                        tasks = distro.search_tasks(**search_args)
                        if reopened:
                            tasks.set_filter_reopened()
                        if statuslength:
                            tasks.set_filter_status_length(statuslength)
                        if implength:
                            tasks.set_filter_status_length(implength)
                        for task in tasks:
                            reported_tasks.append(task)
                if search_limit:
                    return reported_tasks[:search_limit]
                else:
                    return reported_tasks
        if search_assignees != '':
            assigned_tasks = []
            for assignee in search_assignees:
                search_assignee = self.lp.launchpad.people[assignee]
                if search_assignee.is_team is False:
                    search_args['assignee'] = search_assignee
                    tasks = distro.search_tasks(**search_args)
                    if reopened:
                        tasks.set_filter_reopened()
                    if statuslength:
                        tasks.set_filter_status_length(statuslength)
                    if implength:
                        tasks.set_filter_status_length(implength)
                    assigned_tasks.append(tasks)
                    search_assignee_names.append(search_assignee.name)
                else:
                    for participant in search_assignee.participants:
                        if participant.is_team:
                            continue
                        search_args['assignee'] = participant
                        tasks = distro.search_tasks(**search_args)
                        if reopened:
                            tasks.set_filter_reopened()
                        if statuslength:
                            tasks.set_filter_status_length(statuslength)
                        if implength:
                            tasks.set_filter_status_length(implength)
                        for task in tasks:
                            assigned_tasks.append(task)
                if search_limit:
                    return assigned_tasks[:search_limit]
                else:
                    return assigned_tasks
        # Subscribers searches differently than assignee, participant.
        # TODO: consolidate searching by these fields and make the splitting team
        # into participants a configurable feature.
        if search_subscribers != '':
            for subscriber in search_subscribers:
                search_subscriber = self.lp.launchpad.people[subscriber]
                search_args['bug_supervisor'] = search_subscriber
                tasks = distro.search_tasks(**search_args)
                if reopened:
                    tasks.set_filter_reopened()
                if statuslength:
                    tasks.set_filter_status_length(statuslength)
                if implength:
                    tasks.set_filter_status_length(implength)
                if search_limit:
                    return tasks[:search_limit]
                else:
                    return tasks
        else:
            tasks = distro.search_tasks(**search_args)
            if reopened:
                tasks.set_filter_reopened()
            if statuslength:
                tasks.set_filter_status_length(statuslength)
            if implength:
                tasks.set_filter_status_length(implength)
            if search_limit:
                return tasks[:search_limit]
            else:
                return tasks


    # main
    #
    def main(self):
        Dbg.enter("CollectBugData.main")
        retval = -1

        try:
            self.initialize()

            search_start = datetime.utcnow()

            last_run_time = None
            recorded_bugs = []
            # load tasks that were recorded in the json file
            if self.cfg['updated_only']:
                last_run = json_load(self.cfg['json_file'])
                try:
                    recorded_tasks = last_run['tasks']
                    # these were unicode or something
                    recorded_bugs = [str(bug_number) for bug_number in recorded_tasks.keys()]
                except KeyError:
                    print("Old tasks not loaded as they aren't in the json file")
                    recorded_tasks = {}
                try:
                    last_run_timestamp = last_run['update_timestamp']
                    last_run_time = string_to_date(last_run_timestamp)
                except KeyError:
                    print("update_timestamp doesn't appear in the json file")
            iso_tasks = {}
            # sort the bugs for easier debugging
            recorded_bugs.sort()

            # For each 'search_criteria' section of the config file:
            #
            for sc in self.iso_config['search_criteria']:
                try:
                    series = sc['series']
                except KeyError:
                    series = ["NONE"]

                # For each 'series' within the 'search_criteria' section of the
                # config file:
                #
                for s in series:

                    # Perform the search and loop over the search results.
                    #
                    try:
                        for task in self.distro_tasks_search(sc, s, last_run_time):
                            try:
                                bug_number = str(task.bug.id)
                                if not self.cfg['run_quietly']:
                                    stdo("%s\r" % bug_number)

                                # I think this should go down below just before the 'if not matched:'
                                #
                                if bug_number not in iso_tasks:
                                    Dbg.verbose("LP: #%s newly added to iso_tasks\n" % bug_number)
                                    iso_tasks[bug_number] = []
                                    # if the bug appeared in the search results we should reload it
                                if self.cfg['updated_only']:
                                    if bug_number in recorded_bugs:
                                        # Just grab the first bug task
                                        # 2012-04-09 - arges
                                        # If the task is empty, remove it from the list.
                                        # Otherwise, set it as old_bug
                                        if recorded_tasks['%s' % bug_number] == []:
                                            Dbg.verbose("LP: #%s is being removed as its tasks are empty")
                                            recorded_tasks.pop(bug_number)
                                            recorded_bugs.remove(bug_number)
                                            continue
                                        else:
                                            old_bug = recorded_tasks[bug_number][0]
                                        # the date_to_string function removes second, microsecond and tzinfo from date types
                                        # XXX it'd be better for comparisons if date_to_string included seconds, microseconds and tzinfo
                                        last_update = task.bug.date_last_updated.replace(second=0, microsecond=0, tzinfo=None)
                                        try:
                                            if old_bug and last_update <= string_to_date(old_bug['bug']['date_last_updated']):
                                                Dbg.verbose("LP: #%s is being skipped as it hasn't been updated\n" % bug_number)
                                                iso_tasks[bug_number] = recorded_tasks['%s' % bug_number]
                                                # remove the bugs from the recorded_tasks
                                                recorded_tasks.pop(bug_number)
                                                recorded_bugs.remove(bug_number)
                                                continue
                                            elif old_bug and last_update >= string_to_date(old_bug['bug']['date_last_updated']):
                                                Dbg.verbose("LP: #%s needs to be reloaded\n" % bug_number)
                                                # remove the bugs from the recorded_tasks
                                                recorded_tasks.pop(bug_number)
                                                recorded_bugs.remove(bug_number)
                                                iso_tasks[bug_number] = []
                                        except KeyError:
                                            Dbg.warn("Bug %s raised a KeyError exception." % (bug_number))

                                        Dbg.verbose("LP: #%s is being reloaded as it has been updated\n" % bug_number)
                                        iso_tasks[bug_number] = []
                                        if bug_number in recorded_tasks:
                                            recorded_tasks.pop(bug_number)
                                        if bug_number in recorded_bugs:
                                            recorded_bugs.remove(bug_number)

                                try:
                                    # TODO: perhaps we should move the show_private_bugs flag to a search_criteria option?
                                    if 'private_only' in sc.keys():
                                        private_only = sc['private_only']
                                    else:
                                        private_only = False

                                    if (private_only and task.bug.private) or \
                                        (not private_only and (not task.bug.private or self.cfg['show_private_bugs'])):
                                        #Dbg.verbose("Loading task info for %s" % task)

                                        t = self.get_task_info(task)
                                        t['debug']['series'] = s
                                        t_name = t['bug_target_name']
                                        matched = False
                                        for tt in iso_tasks[bug_number]:
                                            if t_name == tt['bug_target_name']:
                                                Dbg.verbose("LP: #%s task match found\n" % bug_number)
                                                matched = True

                                        if not matched:
                                            Dbg.verbose("LP: #%s task match not found\n" % bug_number)
                                            iso_tasks[bug_number].append(t)

                                    else:
                                        Dbg.verbose("Bug %s doesn't match visibility http://pad.lv/%s\n" % (bug_number, bug_number))
                                except HTTPError as e:
                                    print('Exception caught processing bug: %s' % bug_number)
                                    if 'x-lazr-oopsid' in e.response:
                                        print("LaunchPad oops id: %s" % e.response['x-lazr-oopsid'])
                                    else:
                                        print e.content

                            except HTTPError as e:
                                print('HTTPError Exception caught processing an individual task (%s).' % bug_number)
                                if 'x-lazr-oopsid' in e.response:
                                    print("LaunchPad oops id: %s" % e.response['x-lazr-oopsid'])
                                else:
                                    print e.content


                    except HTTPError as e:
                        print('HTTPError Exception caught, processing the tasks_search results list.')
                        if 'x-lazr-oopsid' in e.response:
                            print("LaunchPad oops id: %s" % e.response['x-lazr-oopsid'])
                        else:
                            print e.content


            # Check the remaining bugs loaded from the json file to see if they still match the search criteria
            #   and if they still have an open task add them to iso_tasks.
            for bug_number in recorded_bugs:
                try:
                    bug = self.lp.get_bug(bug_number)
                except KeyError:
                    # Skip the bug because it has become private now
                    Dbg.verbose("LP: #%s has been skipped because it is private now\n" % bug_number)
                    continue
                # if the bug is a duplicate of another remove it
                if bug.duplicate_of is not None:
                    Dbg.verbose("LP: #%s is a dupe now so removing it\n" % bug_number)
                    recorded_tasks.pop(bug_number)
                    recorded_bugs.remove(bug_number)
                    continue
                # check to see if the bug still has tags in our criteria
                tag_set = set(bug.tags)
                if 'tags' in sc:
                    tags = {}
                    for tag in sc['tags']:
                        tags.setdefault('included-tags', [])
                        # tags that start with a "-" are ones we do not
                        # want in the results set
                        if tag.startswith('-'):
                            tags.setdefault('excluded-tags', [])
                            tags['excluded-tags'].append(tag[1:])
                        else:
                            tags['included-tags'].append(tag)
                    if 'tags_combinator' in sc:
                        if sc['tags_combinator'] == 'All' and not tag_set.issuperset(tags['included-tags']):
                            Dbg.verbose("LP: #%s removed as it doesn't have all the required tags\n" % bug_number)
                            recorded_tasks.pop(bug_number)
                            recorded_bugs.remove(bug_number)
                            continue
                        elif sc['tags_combinator'] == 'All' and tag_set.issuperset(tags['included-tags']) and 'excluded-tags' in tags:
                            if tag_set.intersection(tags['excluded-tags']):
                                Dbg.verbose("LP: #%s removed as it has an excluded tag\n" % bug_number)
                                recorded_tasks.pop(bug_number)
                                recorded_bugs.remove(bug_number)
                                continue
                        elif sc['tags_combinator'] == 'Any' and not tag_set.intersection(tags['included-tags']):
                            Dbg.verbose("LP: #%s removed as it doesn't have any of the required tags\n" % bug_number)
                            recorded_tasks.pop(bug_number)
                            recorded_bugs.remove(bug_number)
                            continue
                    # the default for tags_combinator is Any
                    # tags that start with a "-" make no sense with Any
                    else:
                        if not tag_set.intersection(sc['tags']):
                            Dbg.verbose("LP: #%s removed as it doesn't have any of the required tags\n" % bug_number)
                            recorded_tasks.pop(bug_number)
                            recorded_bugs.remove(bug_number)
                            continue
                bug_task_links = [task.web_link for task in bug.tasks]
                # remove the task if it doesn't exist in the bug tasks anymore e.g. the package changed
                for recorded_task in recorded_tasks['%s' % bug_number]:
                    if recorded_task['web_link'] not in bug_task_links:
                        Dbg.verbose("LP: #%s had a task removed\n" % bug_number)
                        recorded_task.clear()
                for task in bug.tasks:
                    if all(len(recorded_task)==0 for recorded_task in recorded_tasks[bug_number]):
                        Dbg.verbose("LP: #%s had no tasks so skipping\n" % bug_number)
                        break
                    # 2012-03-27 change the stati to the defined criteria
                    if task.status not in sc['status']:
                        for recorded_task in recorded_tasks['%s' % bug_number]:
                            if len(recorded_task) == 0:
                                continue
                            if task.web_link == recorded_task['web_link']:
                                # remove the data about the recorded task because it is not in a matching state
                                Dbg.verbose("LP: #%s removed unmatched status task %s\n" % (bug_number, task.web_link))
                                recorded_task.clear()
                                continue
                    if search_assignee_names:
                        # there is no assignee
                        if not task.assignee_name:
                            for recorded_task in recorded_tasks['%s' % bug_number]:
                                # if the task has been cleared but the bug not removed skip it
                                if len(recorded_task) == 0:
                                    continue
                                if all(len(recorded_task)==0 for recorded_task in recorded_tasks[bug_number]):
                                    Dbg.verbose("LP: #%s had no tasks so skipping\n" % bug_number)
                                    break
                                if task.web_link == recorded_task['web_link']:
                                    # remove the data about the recorded task because it is not assigned
                                    Dbg.verbose("LP: #%s removed unassigned task %s\n" % (bug_number, task.web_link))
                                    recorded_task.clear()
                                    continue
                        # the assignee is not in our assignee list
                        elif task.assignee.username not in search_assignee_names:
                            for recorded_task in recorded_tasks['%s' % bug_number]:
                                if all(len(recorded_task)==0 for recorded_task in recorded_tasks[bug_number]):
                                    Dbg.verbose("LP: #%s had no tasks so skipping\n" % bug_number)
                                    break
                                if task.web_link == recorded_task['web_link']:
                                    # remove the data about the recorded task because it not assigned to our people
                                    Dbg.verbose("LP: #%s removed unassigned task %s\n" % (bug_number, task.web_link))
                                    recorded_task.clear()
                                    continue
                # reset recorded_tasks to exclude those that have been cleared
                recorded_tasks[bug_number] = [recorded_task for task in recorded_tasks[bug_number] if recorded_task]
                # if the bug_number no longer has any recorded tasks remove it
                if all(len(recorded_task)==0 for recorded_task in recorded_tasks[bug_number]):
                    Dbg.verbose("LP: #%s has been removed because it has no tasks\n" % bug_number)
                    recorded_tasks.pop(bug_number)
                # added the recorded tasks to iso_tasks
                if bug_number in recorded_tasks.keys():
                    Dbg.verbose("LP: #%s copied from cache to iso_tasks\n" % bug_number)
                    iso_tasks[bug_number] = recorded_tasks[bug_number]
            # Update all the package->team mappings for all the tasks. Given the above optimizations
            # to only update bug tasks that need to be done, the package->team mappings were getting
            # missed even when changes had been made. Since this data is cached, we are not abusing
            # LP to run this update here.
            #
            for task in iso_tasks:
                for t in iso_tasks[task]:
                    #t = iso_tasks[task]
                    if t['bug_target_name'] in self.team_xref:
                        t['team'] = self.team_xref[t['bug_target_name']]
                    else:
                        t['team'] = []

            # Update the configuration file with the LP data and the timestamp
            #
            self.iso_config['tasks'] = iso_tasks
            self.iso_config['update_timestamp'] = date_to_string(search_start)
            with open(self.cfg['json_file'], 'w') as f:
                Dbg.verbose("Updating the database file.\n")
                f.write(json.dumps(self.iso_config, sort_keys=True, indent=4))

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        except HTTPError as e:
            if 'x-lazr-oopsid' in e.response:
                print("LaunchPad oops id: %s" % e.response['x-lazr-oopsid'])
            else:
                print e.content

        except Exit:
            pass

        Dbg.leave("CollectBugData.main")
        return retval

    # get_task_info
    #
    def get_task_info(self, task):
        Dbg.enter("CollectBugData.get_task_info")

        t = {}
        t['debug'] = {}

        m = re.search('(\S+)\s\(.*\)', task.bug_target_name)
        if m is not None:
            name = m.group(1)
        else:
            name = task.bug_target_name

        t['bug_target_name'] = name
        if t['bug_target_name'] in self.team_xref:
            t['team'] = self.team_xref[t['bug_target_name']]
        else:
            t['team'] = []
        t['status'] = task.status
        t['importance'] = task.importance

        try:
            t['assignee'] = task.assignee.display_name
        except:
            t['assignee'] = 'Unassigned'

        t['date_created'] = date_to_string(task.date_created)
        t['date_confirmed'] = date_to_string(task.date_confirmed)
        t['date_assigned'] = date_to_string(task.date_assigned)
        t['date_closed'] = date_to_string(task.date_closed)
        t['date_fix_committed'] = date_to_string(task.date_fix_committed)
        t['date_fix_released'] = date_to_string(task.date_fix_released)
        t['date_in_progress'] = date_to_string(task.date_in_progress)
        t['date_incomplete'] = date_to_string(task.date_incomplete)
        t['date_left_closed'] = date_to_string(task.date_left_closed)
        t['date_left_new'] = date_to_string(task.date_left_new)
        t['date_triaged'] = date_to_string(task.date_triaged)
        t['is_complete'] = task.is_complete
        t['owner'] = task.owner.display_name
        t['title'] = task.title
        t['web_link'] = task.web_link

        try:
            t['debug']['task.milestone.name'] = task.milestone.name
            t['milestone_target'] = self.decode_milestone(task.milestone.name)
        except:
            t['debug']['task.milestone.name'] = ''
            t['milestone_target'] = ''

        t['milestone_found'] = self.determine_milestone_found(task.date_created)

        b = {}
        bug = KernelBug(task.bug)
        b['id'] = bug.id
        b['tags'] = [tag for tag in bug.tags]
        b['title'] = bug.title

        created = bug.date_created
        b['date_created']      = date_to_string(created)
        b['date_last_message'] = date_to_string(bug.date_last_message)
        updated = bug.date_last_updated
        b['date_last_updated'] = date_to_string(updated)
        b['heat']              = bug.heat
        b['number_of_duplicates'] = bug.lpbug.number_of_duplicates
        b['number_of_messages'] = len(bug.messages)
        b['number_affected']    = bug.users_affected_count
        b['number_subscribed']  = len(bug.lpbug.subscriptions)

        b['nominations'] = []
        for nom in bug.nominations:
            if nom.status == 'Approved':
                b['nominations'].append(nom.target.name)

        (b['age_days'], b['age_hours'], b['age_minutes']) = self.how_long_ago(created)
        b['iso_date_created']  = '%s (%d)' % (created.strftime("%Y/%m/%d"), b['age_days'])
        b['last_update'] = '%d' % self.how_long_ago(updated)[0]

        (b['series_name'], b['series_version']) = bug.series
        b['latest_patch_uploaded'] = date_to_string(bug.date_latest_patch_uploaded)
        b['linked_branches'] = []
        for branch in bug.lpbug.linked_branches:
            b['linked_branches'].append(branch.web_link)

        # LiveMediaBuild property
        #
        if 'LiveMediaBuild' in bug.properties:
            lmb = bug.properties['LiveMediaBuild']
            m = re.search('(\S+) (\d+.\d+[.\d+]).*"(\S+ \S+)" - (\S+) (\S+) \((\d+)\)', lmb)
            if m is not None:
                lmb = {}
                lmb['distro'] = m.group(1)
                lmb['version'] = m.group(2)
                lmb['name'] = m.group(3)
                lmb['milestone'] = m.group(4)
                lmb['arch'] = m.group(5)
                lmb['date'] = m.group(6)
                b['LiveMediaBuild'] = lmb

        # Extra Sustaining Engineering fields
        #
        try:
            config = self.iso_config['launchpad_config']
            if 'bug_type' in config.keys():
                if config['bug_type'] == "seg":
                    from seglib import seg
                    b['seg'] = seg.parseSegBug(bug, t['assignee'], t['importance'],b['age_days'])
        except:
            pass

        t['bug'] = b

        Dbg.leave("CollectBugData.get_task_info")
        return t

    def how_long_ago(self, date):
        now = datetime.utcnow()
        now.replace(tzinfo=None)
        ago = DeltaTime(date, now)
        when = '%d.%d.%d' % (ago.days, ago.hours, ago.minutes)

        return (ago.days, ago.hours, ago.minutes)

if __name__ == '__main__':
    defaults = {
        'app_name': argv[0],
        'run_quietly': False,
        'show_private_bugs': False,
        'updated_only': True,
        }

    # The cmdline processing is done here partially so the debug options
    # can be processed right away.
    #
    cmdline = Cmdline()
    try:
        app = CollectBugData(cmdline.process(argv, defaults))
        exit(app.main())
    except CmdlineError as e:
        cmdline.error(e.msg, defaults)

# vi:set ts=4 sw=4 expandtab:
