#!/bin/bash

# TODO: Boilerplate
# Copyright (C) 2008-2012 Canonical Ltd.

# Design:
#   Identify if we're already running and maybe avoid re-running?
#   Identify if process is off the rails, and kill it
#   Store our pid in a run file
#   Allow N processes to run in parallel
#   Direct output to log files
#   Collect output and mail it to arsenal-cron@; see cronmail script

# TODO: Permit configuration via config file
## Source config files, if any
#if [ -f /etc/${NAME}/${NAME}.conf ]; then
#    . /etc/${NAME}/${NAME}.conf
#fi

random_file() {
    echo $(ls -1 $* 2>/dev/null | sort --random-sort | head -n 1)
}

random_word() {
    echo $(for w in $*; do echo "$w" ; done | sort --random-sort | head -n 1)
}

## Make sure we clean up the *.new lock file if we exit for any reason
#trap "rm -f $NEW 2>/dev/null || true" EXIT HUP INT QUIT TERM

# 

# MAX_PROCESSES
#
# Maximum number of processes to run in parallel.  If we're already running
# this many processes, then this script won't run.
#
MAX_PROCESSES=20

# KILL_CHANCE
#
# Percent chance per run to kill an existing arsenal process.  If this is
# non-zero, then when we've hit the maximum number of processes then this
# is the percent chance that instead of exiting we'll kill one of the
# existing processes and run in it's place.
#
# This feature is intended to help in the case where some process is
# taking too much processing time and thus preventing other searches
# from being processed.
#
KILL_CHANCE=10

# CYCLES
#
# We will process this many randomly selected search configs before
# exiting.
#
CYCLES=10


# Process Control
#
# Check if we have hit the limit on number of processes.  If we have, then
# there's a random chance that we'll kill one to make room for us, versus
# just exiting.
PIDS=$(pidof -x $0)
num_procs=$(echo $PIDS | wc -w)
if [ $num_procs -ge $MAX_PROCESSES ]; then
    thresh=$(( 100 / $KILL_CHANCE ))
    chance=$(( $RANDOM % $thresh ))
    if [ $chance -le 1 ]; then 
	echo "Killing one random arsenal process"
	kill -9 $(random_word $PIDS)
    else
	exit 1
    fi
fi

while [ $CYCLES -gt 0 ] ; do
    # Select one team at random
    team=$(ls reports/ | sort --random-sort | head -n 1)
    if [ ! -d "reports/${team}" ]; then
	continue
    fi

    # Select one of the team's search configs (if any)
    search_config=$(random_file "reports/${team}/*.search")
    if [ ! -f "${search_config}" ]; then
	continue
    fi

    # Process the team's search config
    echo scripts/collect-bugs "${search_config}"
    scripts/collect-bugs -o /var/tmp "${search_config}"
    if [ $? -ne 0 ]; then
	echo "Error hit, exiting"
	exit 1
    fi

    CYCLES=$(( CYCLES - 1 ))
    sleep 0.25
done

